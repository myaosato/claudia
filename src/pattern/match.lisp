(defpackage :claudia/pattern/match
  (:use :cl
        :claudia/meta-data/interface)
  (:export :match))
(in-package :claudia/pattern/match)

(defun check (pattern target map)
  (let ((x (gethash (var-name pattern) map)))
    (cond ((null x)
           (setf (gethash (var-name pattern) map) target)
           map)
          ((== x target)
           map)
          (t
           nil))))

(defun match-var (pattern target map)
  (when (and (typep pattern 'var) (typep target 'term))
    (check pattern target map)))
(defun match-const (pattern target map)
  (when (and (typep pattern 'const) (== pattern target))
    map))
(defun match-func (pattern target map)
  (when (and (typep pattern 'func)
             (typep target 'func)
             (let ((xs (func-terms pattern))
                   (ys (func-terms target)))
               (and (= (length xs) (length ys))
                    (every (lambda (x y) (%match x y map)) xs ys))))
    map))
(defun match-∧ (pattern target map)
  (when (and (typep pattern '∧) 
             (typep target '∧)
             (%match (∧-0 pattern) (∧-0 target) map)
             (%match (∧-1 pattern) (∧-1 target) map))
    map))
(defun match-∨ (pattern target map)
  (when (and (typep pattern '∨) 
             (typep target '∨)
             (%match (∨-0 pattern) (∨-0 target) map)
             (%match (∨-1 pattern) (∨-1 target) map))
    map))
(defun match-→ (pattern target map)
  (when (and (typep pattern '→) 
             (typep target '→)
             (%match (→-0 pattern) (→-0 target) map)
             (%match (→-1 pattern) (→-1 target) map))
    map))
(defun match-¬ (pattern target map)
  (when (and (typep pattern '¬) 
             (typep target '¬)
             (%match (¬-0 pattern) (¬-0 target) map))
    map))
(defun match-prop (pattern target map)
  (when (and (typep pattern 'prop)
             (== pattern target))
    map))
(defun match-predicate (pattern target map)
  (when (and (typep pattern 'predicate)
             (typep target 'predicate)
             (let ((xs (predicate-terms pattern))
                   (ys (predicate-terms target)))
               (and (= (length xs) (length ys))
                    (every (lambda (x y) (%match x y map)) xs ys))))
    map))
(defun match-∀ (pattern target map)
  (when (and (typep pattern '∀)
             (typep target '∀)
             (%match (∀-var pattern) (∀-var target) map)
             (%match (∀-formula pattern) (∀-formula target) map))
    (remhash (var-name (∀-var pattern)) map)
    map))
(defun match-∃ (pattern target map)
  (when (and (typep pattern '∃)
             (typep target '∃)
             (%match (∃-var pattern) (∃-var target) map)
             (%match (∃-formula pattern) (∃-formula target) map))
    (remhash (var-name (∃-var pattern)) map)
    map))

(defun %match (pattern target map)
  (or (match-var pattern target map)
      (match-const pattern target map)
      (match-func pattern target map)
      (match-∧ pattern target map)
      (match-∨ pattern target map)
      (match-→ pattern target map)
      (match-¬ pattern target map)
      (match-prop pattern target map)
      (match-predicate pattern target map)
      (match-∀ pattern target map)
      (match-∃ pattern target map)))

(defun match (pattern target)
  (%match pattern target (make-hash-table)))
